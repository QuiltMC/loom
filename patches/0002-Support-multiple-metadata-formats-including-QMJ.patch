From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Glitch <glitch.g3431@gmail.com>
Date: Sat, 12 Mar 2022 21:42:51 -0600
Subject: [PATCH] Support multiple metadata formats, including QMJ

Co-authored-by: Kneelawk <kneelawk@gmail.com>

fix reading access wideners

diff --git a/src/main/java/net/fabricmc/loom/LoomGradleExtension.java b/src/main/java/net/fabricmc/loom/LoomGradleExtension.java
index 72546cdb6255dbbd7dae478e6b0dd50616d7f9f7..aafeeb9644d51c024500301bed42074f36c01408 100644
--- a/src/main/java/net/fabricmc/loom/LoomGradleExtension.java
+++ b/src/main/java/net/fabricmc/loom/LoomGradleExtension.java
@@ -24,6 +24,7 @@
 
 package net.fabricmc.loom;
 
+import java.io.File;
 import java.nio.file.Path;
 import java.util.List;
 import java.util.function.Supplier;
@@ -38,6 +39,7 @@ import net.fabricmc.loom.api.LoomGradleExtensionAPI;
 import net.fabricmc.loom.api.mappings.layered.MappingsNamespace;
 import net.fabricmc.loom.configuration.InstallerData;
 import net.fabricmc.loom.configuration.LoomDependencyManager;
+import net.fabricmc.loom.configuration.ModMetadataHelper;
 import net.fabricmc.loom.configuration.accesswidener.AccessWidenerFile;
 import net.fabricmc.loom.configuration.processors.JarProcessorManager;
 import net.fabricmc.loom.configuration.providers.mappings.MappingsProviderImpl;
@@ -47,6 +49,7 @@ import net.fabricmc.loom.configuration.providers.minecraft.mapped.NamedMinecraft
 import net.fabricmc.loom.extension.LoomFiles;
 import net.fabricmc.loom.extension.MixinExtension;
 import net.fabricmc.loom.util.download.DownloadBuilder;
+import net.fabricmc.loom.util.ModUtils;
 
 public interface LoomGradleExtension extends LoomGradleExtensionAPI {
 	static LoomGradleExtension get(Project project) {
@@ -113,4 +116,11 @@ public interface LoomGradleExtension extends LoomGradleExtensionAPI {
 	boolean refreshDeps();
 
 	void setRefreshDeps(boolean refreshDeps);
+
+	/**
+	 * @throws UnsupportedOperationException if the jar file has more than one kind of metadata, or the metadata that is found cannot be read.
+	 */
+	default ModMetadataHelper.Metadata readMetadataFromJar(File jar) {
+		return ModUtils.readMetadataFromJar(getModMetadataHelpers().get(), getMetadataPriorities().get(), jar);
+	}
 }
diff --git a/src/main/java/net/fabricmc/loom/api/InterfaceInjectionExtensionAPI.java b/src/main/java/net/fabricmc/loom/api/InterfaceInjectionExtensionAPI.java
index 5a3cfbd337827f0fe4df2971ef68b3e169ae6b9f..30caf442a8650cebb11daeea280671a56d1bd3e6 100644
--- a/src/main/java/net/fabricmc/loom/api/InterfaceInjectionExtensionAPI.java
+++ b/src/main/java/net/fabricmc/loom/api/InterfaceInjectionExtensionAPI.java
@@ -39,7 +39,7 @@ public interface InterfaceInjectionExtensionAPI {
 	Property<Boolean> getEnableDependencyInterfaceInjection();
 
 	/**
-	 * Contains a list of {@link SourceSet} that may contain a fabric.mod.json file with interfaces to inject.
+	 * Contains a list of {@link SourceSet} that may contain a mod metadata file with interfaces to inject.
 	 * By default, this list contains only the main {@link SourceSet}.
 	 *
 	 * @return the list property containing the {@link SourceSet}
diff --git a/src/main/java/net/fabricmc/loom/api/LoomGradleExtensionAPI.java b/src/main/java/net/fabricmc/loom/api/LoomGradleExtensionAPI.java
index 693f1d55b51965416208a8a27e07fdc391f0741f..5b8b42580c5351f6ae27e58b376c9c7a6e729361 100644
--- a/src/main/java/net/fabricmc/loom/api/LoomGradleExtensionAPI.java
+++ b/src/main/java/net/fabricmc/loom/api/LoomGradleExtensionAPI.java
@@ -34,6 +34,7 @@ import org.gradle.api.artifacts.Dependency;
 import org.gradle.api.file.ConfigurableFileCollection;
 import org.gradle.api.file.RegularFileProperty;
 import org.gradle.api.provider.ListProperty;
+import org.gradle.api.provider.MapProperty;
 import org.gradle.api.provider.Property;
 import org.gradle.api.publish.maven.MavenPublication;
 import org.gradle.api.tasks.SourceSet;
@@ -42,6 +43,8 @@ import org.jetbrains.annotations.ApiStatus;
 import net.fabricmc.loom.api.decompilers.DecompilerOptions;
 import net.fabricmc.loom.api.mappings.intermediate.IntermediateMappingsProvider;
 import net.fabricmc.loom.api.mappings.layered.spec.LayeredMappingSpecBuilder;
+import net.fabricmc.loom.api.metadata.MetadataPriorities;
+import net.fabricmc.loom.configuration.ModMetadataHelper;
 import net.fabricmc.loom.configuration.ide.RunConfigSettings;
 import net.fabricmc.loom.configuration.processors.JarProcessor;
 import net.fabricmc.loom.configuration.providers.mappings.NoOpIntermediateMappingsProvider;
@@ -68,6 +71,16 @@ public interface LoomGradleExtensionAPI {
 		getGameJarProcessors().add(processor);
 	}
 
+	MapProperty<String, ModMetadataHelper> getModMetadataHelpers();
+
+	default void addModMetadataHelper(ModMetadataHelper api) {
+		getModMetadataHelpers().put(api.getFileName(), api);
+	}
+
+	void metadataPriorities(Action<MetadataPriorities> action);
+
+	Property<MetadataPriorities> getMetadataPriorities();
+
 	ConfigurableFileCollection getLog4jConfigs();
 
 	Dependency officialMojangMappings();
@@ -126,10 +139,10 @@ public interface LoomGradleExtensionAPI {
 	void disableDeprecatedPomGeneration(MavenPublication publication);
 
 	/**
-	 * Reads the mod version from the fabric.mod.json file located in the main sourcesets resources.
+	 * Reads the mod version from the mod metadata file located in the main sourcesets resources.
 	 * This is useful if you want to set the gradle version based of the version in the fabric.mod.json file.
 	 *
-	 * @return the version defined in the fabric.mod.json
+	 * @return the version defined in the mod metadata
 	 */
 	String getModVersion();
 
diff --git a/src/main/java/net/fabricmc/loom/api/metadata/MetadataPriorities.java b/src/main/java/net/fabricmc/loom/api/metadata/MetadataPriorities.java
new file mode 100644
index 0000000000000000000000000000000000000000..62ad2b9f63443b722daf15316897b861e3a28f81
--- /dev/null
+++ b/src/main/java/net/fabricmc/loom/api/metadata/MetadataPriorities.java
@@ -0,0 +1,55 @@
+/*
+ * This file is part of fabric-loom, licensed under the MIT License (MIT).
+ *
+ * Copyright (c) 2022 FabricMC
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+package net.fabricmc.loom.api.metadata;
+
+import java.io.Serializable;
+
+/**
+ * Configures different metadata file priorities.
+ *
+ * <p>The default priorities are:
+ * <ul>
+ *     <li><code>quilt.mod.json</code>: priority 1.</li>
+ *     <li><code>fabric.mod.json</code>: priority 0.</li>
+ *     <li>All other metadata kinds have a priority of -1 by default.</li>
+ * </ul>
+ */
+public interface MetadataPriorities extends Serializable {
+	/**
+	 * Sets the priority of a metadata kind by filename.
+	 *
+	 * @param filename the filename of the metadata kind to set the priority of.
+	 * @param priority the priority of the metadata kind. Higher values give higher priority.
+	 */
+	void priority(String filename, int priority);
+
+	/**
+	 * Gets the priority of a metadata kind by filename.
+	 *
+	 * @param filename the filename of the metadata kind to get the priority of.
+	 * @return the priority of the requested metadata kind.
+	 */
+	int getPriority(String filename);
+}
diff --git a/src/main/java/net/fabricmc/loom/build/FabricModMetadataHelper.java b/src/main/java/net/fabricmc/loom/build/FabricModMetadataHelper.java
new file mode 100644
index 0000000000000000000000000000000000000000..b32a9cd69862b9a661b48587ebee70a036aaa6b8
--- /dev/null
+++ b/src/main/java/net/fabricmc/loom/build/FabricModMetadataHelper.java
@@ -0,0 +1,233 @@
+/*
+ * This file is part of fabric-loom, licensed under the MIT License (MIT).
+ *
+ * Copyright (c) 2022 FabricMC
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+package net.fabricmc.loom.build;
+
+import java.io.File;
+import java.io.FileReader;
+import java.io.IOException;
+import java.io.Reader;
+import java.nio.file.Path;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.List;
+import java.util.stream.Collectors;
+import java.util.stream.StreamSupport;
+
+import com.google.gson.JsonArray;
+import com.google.gson.JsonElement;
+import com.google.gson.JsonObject;
+import com.google.gson.JsonPrimitive;
+import org.jetbrains.annotations.Nullable;
+
+import net.fabricmc.loom.LoomGradlePlugin;
+import net.fabricmc.loom.configuration.ModMetadataHelper;
+import net.fabricmc.loom.util.Constants;
+import net.fabricmc.loom.util.ZipUtils;
+
+public final class FabricModMetadataHelper implements ModMetadataHelper {
+	@Override
+	public String getFileName() {
+		return "fabric.mod.json";
+	}
+
+	@Override
+	public Metadata createMetadata(File input) {
+		return new Helper(readFabricModJson(input));
+	}
+
+	@Override
+	public Metadata createMetadata(Path input) {
+		return new Helper(readFabricModJson(input.toFile()));
+	}
+
+	@Override
+	public Metadata createMetadata(Reader reader) {
+		return new Helper(LoomGradlePlugin.GSON.fromJson(reader, JsonObject.class));
+	}
+
+	@Override
+	public ZipUtils.UnsafeUnaryOperator<JsonObject> stripNestedJarsFunction() {
+		return json -> {
+			json.remove("jars");
+			return json;
+		};
+	}
+
+	@Override
+	public ZipUtils.UnsafeUnaryOperator<JsonObject> addNestedJarsFunction(List<String> files) {
+		return json -> {
+			JsonArray nestedJars = json.getAsJsonArray("jars");
+
+			if (nestedJars == null || !json.has("jars")) {
+				nestedJars = new JsonArray();
+			}
+
+			for (String nestedJarPath : files) {
+				for (JsonElement nestedJar : nestedJars) {
+					JsonObject jsonObject = nestedJar.getAsJsonObject();
+
+					if (jsonObject.has("file") && jsonObject.get("file").getAsString().equals(nestedJarPath)) {
+						throw new IllegalStateException("Cannot nest 2 jars at the same path: " + nestedJarPath);
+					}
+				}
+
+				JsonObject jsonObject = new JsonObject();
+				jsonObject.addProperty("file", nestedJarPath);
+				nestedJars.add(jsonObject);
+			}
+
+			json.add("jars", nestedJars);
+
+			return json;
+		};
+	}
+
+	private JsonObject readFabricModJson(File input) {
+		JsonObject jsonObject;
+
+		try (var reader = new FileReader(input)) {
+			jsonObject = LoomGradlePlugin.GSON.fromJson(reader, JsonObject.class);
+		} catch (IOException e) {
+			throw new UnsupportedOperationException("Failed to read fabric.mod.json file", e);
+		}
+
+		return jsonObject;
+	}
+
+	final class Helper implements Metadata {
+		final JsonObject fabricModJson;
+
+		Helper(JsonObject fmj) {
+			this.fabricModJson = fmj;
+		}
+
+		@Override
+		public Collection<String> getMixinConfigurationFiles() {
+			JsonArray mixins = fabricModJson.getAsJsonArray("mixins");
+
+			if (mixins == null) {
+				return Collections.emptyList();
+			}
+
+			return StreamSupport.stream(mixins.spliterator(), false)
+					.map(e -> {
+						if (e instanceof JsonPrimitive str) {
+							return str.getAsString();
+						} else if (e instanceof JsonObject obj) {
+							return obj.get("config").getAsString();
+						} else {
+							throw new RuntimeException("Incorrect fabric.mod.json format");
+						}
+					}).collect(Collectors.toSet());
+		}
+
+		@Override
+		public String getVersion() {
+			if (!fabricModJson.has("version") || !fabricModJson.get("version").isJsonPrimitive()) {
+				return null;
+			}
+
+			return fabricModJson.get("version").getAsString();
+		}
+
+		@Override
+		public @Nullable String getName() {
+			if (!fabricModJson.has("name") || !fabricModJson.get("name").isJsonPrimitive()) {
+				return null;
+			}
+
+			return fabricModJson.get("name").getAsString();
+		}
+
+		@Override
+		public @Nullable String getId() {
+			if (!fabricModJson.has("id") || !fabricModJson.get("id").isJsonPrimitive()) {
+				return null;
+			}
+
+			return fabricModJson.get("id").getAsString();
+		}
+
+		@Override
+		public @Nullable String getAccessWidener() {
+			if (!fabricModJson.has("accessWidener") || !fabricModJson.get("accessWidener").isJsonPrimitive()) {
+				return null;
+			}
+
+			return fabricModJson.get("accessWidener").getAsString();
+		}
+
+		@Override
+		public List<InjectedInterface> getInjectedInterfaces() {
+			final String modId = getId();
+
+			if (!fabricModJson.has("custom")) {
+				return Collections.emptyList();
+			}
+
+			final JsonObject custom = fabricModJson.getAsJsonObject("custom");
+
+			if (!custom.has(Constants.CustomModJsonKeys.INJECTED_INTERFACE)) {
+				return Collections.emptyList();
+			}
+
+			final JsonObject addedIfaces = custom.getAsJsonObject(Constants.CustomModJsonKeys.INJECTED_INTERFACE);
+
+			final List<InjectedInterface> result = new ArrayList<>();
+
+			for (String className : addedIfaces.keySet()) {
+				final JsonArray ifaceNames = addedIfaces.getAsJsonArray(className);
+
+				for (JsonElement ifaceName : ifaceNames) {
+					result.add(new InjectedInterface(modId, className, ifaceName.getAsString()));
+				}
+			}
+
+			return result;
+		}
+
+		@Override
+		@Nullable
+		public String getProvidedJavadocPath() {
+			JsonObject custom = fabricModJson.getAsJsonObject("custom");
+
+			if (custom == null) {
+				return null;
+			}
+
+			if (!custom.has(Constants.CustomModJsonKeys.PROVIDED_JAVADOC)) {
+				return null;
+			}
+
+			return custom.getAsJsonPrimitive(Constants.CustomModJsonKeys.PROVIDED_JAVADOC).getAsString();
+		}
+
+		@Override
+		public ModMetadataHelper getParent() {
+			return FabricModMetadataHelper.this;
+		}
+	}
+}
diff --git a/src/main/java/net/fabricmc/loom/build/QuiltModMetadataHelper.java b/src/main/java/net/fabricmc/loom/build/QuiltModMetadataHelper.java
new file mode 100644
index 0000000000000000000000000000000000000000..1babd7064b952db00f96d65476090abac6152976
--- /dev/null
+++ b/src/main/java/net/fabricmc/loom/build/QuiltModMetadataHelper.java
@@ -0,0 +1,273 @@
+/*
+ * This file is part of fabric-loom, licensed under the MIT License (MIT).
+ *
+ * Copyright (c) 2022 FabricMC
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+package net.fabricmc.loom.build;
+
+import java.io.File;
+import java.io.FileReader;
+import java.io.IOException;
+import java.io.Reader;
+import java.nio.file.Path;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.List;
+import java.util.stream.Collectors;
+import java.util.stream.StreamSupport;
+
+import com.google.gson.JsonArray;
+import com.google.gson.JsonElement;
+import com.google.gson.JsonObject;
+import com.google.gson.JsonPrimitive;
+import org.jetbrains.annotations.Nullable;
+
+import net.fabricmc.loom.LoomGradlePlugin;
+import net.fabricmc.loom.configuration.ModMetadataHelper;
+import net.fabricmc.loom.util.ZipUtils;
+
+// TODO Quilt: De-deuplicate with FabricModMetadataHelper
+public final class QuiltModMetadataHelper implements ModMetadataHelper {
+	@Override
+	public String getFileName() {
+		return "quilt.mod.json";
+	}
+
+	@Override
+	public Metadata createMetadata(File input) {
+		return new Helper(readQmj(input));
+	}
+
+	@Override
+	public Metadata createMetadata(Path input) {
+		return new Helper(readQmj(input.toFile()));
+	}
+
+	@Override
+	public Metadata createMetadata(Reader reader) {
+		return new Helper(LoomGradlePlugin.GSON.fromJson(reader, JsonObject.class));
+	}
+
+	@Override
+	public ZipUtils.UnsafeUnaryOperator<JsonObject> stripNestedJarsFunction() {
+		return json -> {
+			JsonObject loader;
+
+			if (!json.has("quilt_loader") || !json.get("quilt_loader").isJsonObject()) {
+				loader = new JsonObject();
+			} else {
+				loader = json.get("quilt_loader").getAsJsonObject();
+			}
+
+			loader.remove("jars");
+			return json;
+		};
+	}
+
+	@Override
+	public ZipUtils.UnsafeUnaryOperator<JsonObject> addNestedJarsFunction(List<String> files) {
+		return json -> {
+			JsonObject loader;
+
+			if (!json.has("quilt_loader") || !json.get("quilt_loader").isJsonObject()) {
+				loader = new JsonObject();
+			} else {
+				loader = json.get("quilt_loader").getAsJsonObject();
+			}
+
+			JsonArray nestedJars = loader.getAsJsonArray("jars");
+
+			if (nestedJars == null || !loader.has("jars")) {
+				nestedJars = new JsonArray();
+			}
+
+			for (String nestedJarPath : files) {
+				for (JsonElement nestedJar : nestedJars) {
+					String string = nestedJar.getAsString();
+
+					if (nestedJarPath.equals(string)) {
+						throw new IllegalStateException("Cannot nest 2 jars at the same path: " + nestedJarPath);
+					}
+				}
+
+				nestedJars.add(nestedJarPath);
+			}
+
+			loader.add("jars", nestedJars);
+
+			return json;
+		};
+	}
+
+	private JsonObject readQmj(File input) {
+		JsonObject jsonObject;
+
+		try (var reader = new FileReader(input)) {
+			jsonObject = LoomGradlePlugin.GSON.fromJson(reader, JsonObject.class);
+		} catch (IOException e) {
+			throw new UnsupportedOperationException("Failed to read mod metadata file", e);
+		}
+
+		return jsonObject;
+	}
+
+	final class Helper implements Metadata {
+		final JsonObject qmj;
+		final JsonObject loader;
+		final JsonObject metadata;
+
+		Helper(JsonObject fmj) {
+			this.qmj = fmj;
+
+			if (!qmj.has("quilt_loader") || !qmj.get("quilt_loader").isJsonObject()) {
+				this.loader = new JsonObject();
+			} else {
+				loader = qmj.get("quilt_loader").getAsJsonObject();
+			}
+
+			if (!loader.has("metadata") || !loader.get("metadata").isJsonObject()) {
+				this.metadata = new JsonObject();
+			} else {
+				metadata = loader.get("metadata").getAsJsonObject();
+			}
+		}
+
+		@Override
+		public Collection<String> getMixinConfigurationFiles() {
+			JsonElement mixins = qmj.get("mixin");
+
+			if (mixins == null) {
+				return Collections.emptyList();
+			} else if (mixins.isJsonArray()) {
+				return StreamSupport.stream(mixins.getAsJsonArray().spliterator(), false)
+						.map(e -> {
+							if (e instanceof JsonPrimitive str) {
+								return str.getAsString();
+							} else {
+								throw new RuntimeException("Incorrect QMJ format; expected 'mixin' to be a string or array");
+							}
+						}).collect(Collectors.toSet());
+			} else if (mixins.isJsonPrimitive() && mixins.getAsJsonPrimitive().isString()) {
+				return Collections.singleton(mixins.getAsJsonPrimitive().getAsString());
+			} else {
+				throw new RuntimeException("Incorrect QMJ format; expected 'mixin' to be a string or array");
+			}
+		}
+
+		@Override
+		public String getVersion() {
+			if (!loader.has("version") || !loader.get("version").isJsonPrimitive()) {
+				return null;
+			}
+
+			return loader.get("version").getAsString();
+		}
+
+		@Override
+		public @Nullable String getName() {
+			if (!metadata.has("name") || !metadata.get("name").isJsonPrimitive()) {
+				return null;
+			}
+
+			return metadata.get("name").getAsString();
+		}
+
+		@Override
+		public @Nullable String getId() {
+			if (!loader.has("id") || !loader.get("id").isJsonPrimitive()) {
+				return null;
+			}
+
+			return loader.get("id").getAsString();
+		}
+
+		@Override
+		public @Nullable String getAccessWidener() {
+			if (!qmj.has("access_widener")) {
+				return null;
+			}
+
+			// Only allow the "access_widener" array to have one element
+			if (qmj.get("access_widener").isJsonArray()) {
+				JsonArray array = qmj.get("access_widener").getAsJsonArray();
+
+				if (array.size() != 1) {
+					throw new UnsupportedOperationException("Loom does not support multiple access wideners in one mod!");
+				}
+
+				return array.get(0).getAsString();
+			}
+
+			return qmj.get("access_widener").getAsString();
+		}
+
+		@Override
+		public List<InjectedInterface> getInjectedInterfaces() {
+			final String modId = getId();
+
+			if (!qmj.has("quilt_loom")) {
+				return Collections.emptyList();
+			}
+
+			final JsonObject custom = qmj.getAsJsonObject("quilt_loom");
+
+			if (!custom.has("injected_interfaces")) {
+				return Collections.emptyList();
+			}
+
+			final JsonObject addedIfaces = custom.getAsJsonObject("injected_interfaces");
+
+			final List<InjectedInterface> result = new ArrayList<>();
+
+			for (String className : addedIfaces.keySet()) {
+				final JsonArray ifaceNames = addedIfaces.getAsJsonArray(className);
+
+				for (JsonElement ifaceName : ifaceNames) {
+					result.add(new InjectedInterface(modId, className, ifaceName.getAsString()));
+				}
+			}
+
+			return result;
+		}
+
+		@Override
+		public @Nullable String getProvidedJavadocPath() {
+			if (!qmj.has("quilt_loom")) {
+				return null;
+			}
+
+			final JsonObject custom = qmj.getAsJsonObject("quilt_loom");
+
+			if (!custom.has("provided_javadoc_path")) {
+				return null;
+			}
+
+			return custom.get("provided_javadoc_path").getAsString();
+		}
+
+		@Override
+		public ModMetadataHelper getParent() {
+			return QuiltModMetadataHelper.this;
+		}
+	}
+}
diff --git a/src/main/java/net/fabricmc/loom/build/nesting/IncludedJarFactory.java b/src/main/java/net/fabricmc/loom/build/nesting/IncludedJarFactory.java
index 1a833a7618f50d9f9c408946b9790ccbf01cb83b..c7f5253d7401767eb6138908b437d68351c456ec 100644
--- a/src/main/java/net/fabricmc/loom/build/nesting/IncludedJarFactory.java
+++ b/src/main/java/net/fabricmc/loom/build/nesting/IncludedJarFactory.java
@@ -143,12 +143,13 @@ public final class IncludedJarFactory {
 	}
 
 	private File getNestableJar(final File input, final Metadata metadata) {
-		if (ModUtils.isMod(input)) {
+		LoomGradleExtension extension = LoomGradleExtension.get(project);
+
+		if (ModUtils.isMod(extension, input)) {
 			// Input is a mod, nothing needs to be done.
 			return input;
 		}
 
-		LoomGradleExtension extension = LoomGradleExtension.get(project);
 		File tempDir = new File(extension.getFiles().getUserCache(), "temp/modprocessing");
 
 		if (!tempDir.exists()) {
diff --git a/src/main/java/net/fabricmc/loom/build/nesting/JarNester.java b/src/main/java/net/fabricmc/loom/build/nesting/JarNester.java
index 06bf4b5760c77c13aa1c4a23ddd57da81da862d4..e15e1be3146ae1a048eac376915afaa904ec593d 100644
--- a/src/main/java/net/fabricmc/loom/build/nesting/JarNester.java
+++ b/src/main/java/net/fabricmc/loom/build/nesting/JarNester.java
@@ -27,29 +27,32 @@ package net.fabricmc.loom.build.nesting;
 import java.io.File;
 import java.io.IOException;
 import java.nio.file.Files;
+import java.util.ArrayList;
 import java.util.Collection;
+import java.util.List;
+import java.util.Map;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
 
 import com.google.common.base.Preconditions;
-import com.google.gson.JsonArray;
-import com.google.gson.JsonElement;
 import com.google.gson.JsonObject;
 import org.gradle.api.UncheckedIOException;
 import org.slf4j.Logger;
 
+import net.fabricmc.loom.api.metadata.MetadataPriorities;
+import net.fabricmc.loom.configuration.ModMetadataHelper;
 import net.fabricmc.loom.util.ModUtils;
 import net.fabricmc.loom.util.Pair;
 import net.fabricmc.loom.util.ZipUtils;
 
 public class JarNester {
-	public static void nestJars(Collection<File> jars, File modJar, Logger logger) {
+	public static void nestJars(Map<String, ModMetadataHelper> helpers, MetadataPriorities priorities, Collection<File> jars, File modJar, Logger logger) {
 		if (jars.isEmpty()) {
 			logger.debug("Nothing to nest into " + modJar.getName());
 			return;
 		}
 
-		Preconditions.checkArgument(ModUtils.isMod(modJar), "Cannot nest jars into none mod jar " + modJar.getName());
+		Preconditions.checkArgument(ModUtils.isMod(helpers, modJar), "Cannot nest jars into non-mod jar " + modJar.getName());
 
 		try {
 			ZipUtils.add(modJar.toPath(), jars.stream().map(file -> {
@@ -59,37 +62,17 @@ public class JarNester {
 					throw new UncheckedIOException(e);
 				}
 			}).collect(Collectors.toList()));
+			List<String> files = new ArrayList<>();
 
-			int count = ZipUtils.transformJson(JsonObject.class, modJar.toPath(), Stream.of(new Pair<>("fabric.mod.json", json -> {
-				JsonArray nestedJars = json.getAsJsonArray("jars");
+			for (File file : jars) {
+				String nestedJarPath = "META-INF/jars/" + file.getName();
+				Preconditions.checkArgument(ModUtils.isMod(helpers, file), "Cannot nest non-mod jar: " + file.getName());
+				files.add(nestedJarPath);
+			}
 
-				if (nestedJars == null || !json.has("jars")) {
-					nestedJars = new JsonArray();
-				}
-
-				for (File file : jars) {
-					String nestedJarPath = "META-INF/jars/" + file.getName();
-					Preconditions.checkArgument(ModUtils.isMod(file), "Cannot nest none mod jar: " + file.getName());
-
-					for (JsonElement nestedJar : nestedJars) {
-						JsonObject jsonObject = nestedJar.getAsJsonObject();
-
-						if (jsonObject.has("file") && jsonObject.get("file").getAsString().equals(nestedJarPath)) {
-							throw new IllegalStateException("Cannot nest 2 jars at the same path: " + nestedJarPath);
-						}
-					}
-
-					JsonObject jsonObject = new JsonObject();
-					jsonObject.addProperty("file", nestedJarPath);
-					nestedJars.add(jsonObject);
-
-					logger.debug("Nested " + nestedJarPath + " into " + modJar.getName());
-				}
-
-				json.add("jars", nestedJars);
+			ModMetadataHelper helper = ModUtils.readMetadataFromJar(helpers, priorities, modJar).getParent();
 
-				return json;
-			})));
+			int count = ZipUtils.transformJson(JsonObject.class, modJar.toPath(), Stream.of(new Pair<>(helper.getFileName(), helper.addNestedJarsFunction(files))));
 
 			Preconditions.checkState(count > 0, "Failed to transform fabric.mod.json");
 		} catch (IOException e) {
diff --git a/src/main/java/net/fabricmc/loom/configuration/FileDependencyInfo.java b/src/main/java/net/fabricmc/loom/configuration/FileDependencyInfo.java
index 2f55bbe07081c750763d9351c6ff8fa9c575f787..e3343e29dd5ad0eff926d48c52f5455cf32e5d9f 100644
--- a/src/main/java/net/fabricmc/loom/configuration/FileDependencyInfo.java
+++ b/src/main/java/net/fabricmc/loom/configuration/FileDependencyInfo.java
@@ -25,9 +25,6 @@
 package net.fabricmc.loom.configuration;
 
 import java.io.File;
-import java.io.IOException;
-import java.io.UncheckedIOException;
-import java.nio.charset.StandardCharsets;
 import java.util.Comparator;
 import java.util.HashMap;
 import java.util.List;
@@ -36,15 +33,13 @@ import java.util.Set;
 import java.util.stream.Collectors;
 
 import com.google.common.collect.Iterables;
-import com.google.gson.Gson;
-import com.google.gson.JsonObject;
 import org.apache.commons.io.FilenameUtils;
 import org.gradle.api.InvalidUserDataException;
 import org.gradle.api.Project;
 import org.gradle.api.artifacts.Configuration;
 import org.gradle.api.artifacts.SelfResolvingDependency;
 
-import net.fabricmc.loom.util.ZipUtils;
+import net.fabricmc.loom.LoomGradleExtension;
 
 public class FileDependencyInfo extends DependencyInfo {
 	protected final Map<String, File> classifierToFile = new HashMap<>();
@@ -97,31 +92,32 @@ public class FileDependencyInfo extends DependencyInfo {
 		} else {
 			group = "net.fabricmc.synthetic";
 			File root = classifierToFile.get(""); //We've built the classifierToFile map, now to try find a name and version for our dependency
-			byte[] modJson;
-
-			try {
-				if ("jar".equals(FilenameUtils.getExtension(root.getName())) && (modJson = ZipUtils.unpackNullable(root.toPath(), "fabric.mod.json")) != null) {
-					//It's a Fabric mod, see how much we can extract out
-					JsonObject json = new Gson().fromJson(new String(modJson, StandardCharsets.UTF_8), JsonObject.class);
-
-					if (json == null || !json.has("id") || !json.has("version")) {
-						throw new IllegalArgumentException("Invalid Fabric mod jar: " + root + " (malformed json: " + json + ')');
-					}
-
-					if (json.has("name")) { //Go for the name field if it's got one
-						name = json.get("name").getAsString();
-					} else {
-						name = json.get("id").getAsString();
-					}
-
-					version = json.get("version").getAsString();
-				} else {
-					//Not a Fabric mod, just have to make something up
-					name = FilenameUtils.removeExtension(root.getName());
-					version = "1.0";
+			ModMetadataHelper.Metadata metadata;
+
+			if ("jar".equals(FilenameUtils.getExtension(root.getName())) && (metadata = LoomGradleExtension.get(project).readMetadataFromJar(root)) != null) {
+				// It has metadata we can parse; try to extract as much as we can out of it
+				String name;
+				name = metadata.getName();
+
+				if (name == null) {
+					name = metadata.getId();
+				}
+
+				if (name == null) {
+					throw new IllegalArgumentException("Invalid mod jar: " + root);
+				}
+
+				this.name = name;
+
+				version = metadata.getVersion();
+
+				if (version == null) {
+					throw new IllegalArgumentException("Invalid mod jar: " + root);
 				}
-			} catch (IOException e) {
-				throw new UncheckedIOException("Failed to read input file: " + root, e);
+			} else {
+				//Not a Fabric mod, just have to make something up
+				name = FilenameUtils.removeExtension(root.getName());
+				version = "1.0";
 			}
 		}
 	}
diff --git a/src/main/java/net/fabricmc/loom/configuration/ModMetadataHelper.java b/src/main/java/net/fabricmc/loom/configuration/ModMetadataHelper.java
new file mode 100644
index 0000000000000000000000000000000000000000..eaf4403a69463ba7f36a0ff2e953240e37cd640e
--- /dev/null
+++ b/src/main/java/net/fabricmc/loom/configuration/ModMetadataHelper.java
@@ -0,0 +1,100 @@
+/*
+ * This file is part of fabric-loom, licensed under the MIT License (MIT).
+ *
+ * Copyright (c) 2022 FabricMC
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+package net.fabricmc.loom.configuration;
+
+import java.io.File;
+import java.io.Reader;
+import java.io.Serializable;
+import java.nio.file.Path;
+import java.util.Collection;
+import java.util.List;
+
+import com.google.gson.JsonObject;
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.Nullable;
+
+import net.fabricmc.loom.util.ZipUtils;
+
+@ApiStatus.Experimental // This may change at any time as new features are added to Loom
+public interface ModMetadataHelper extends Serializable {
+	String getFileName();
+
+	/**
+	 * @throws UnsupportedOperationException if the mod metadata cannot be read
+	 */
+	Metadata createMetadata(File input);
+	Metadata createMetadata(Path input);
+	Metadata createMetadata(Reader reader);
+
+	ZipUtils.UnsafeUnaryOperator<JsonObject> stripNestedJarsFunction();
+
+	/**
+	 * @throws IllegalStateException in the returned runnable if any duplicated nested jars are added
+	 */
+	ZipUtils.UnsafeUnaryOperator<JsonObject> addNestedJarsFunction(List<String> files);
+
+	interface Metadata {
+		ModMetadataHelper getParent();
+		Collection<String> getMixinConfigurationFiles();
+
+		/**
+		 * @return null if the provided mod metadata does not include a version
+		 */
+		@Nullable
+		String getVersion();
+
+		/**
+		 * The name of this mod, e.g. "Fabric Example Mod"
+		 * @return null if the provided mod metadata does not include a name
+		 */
+		@Nullable
+		String getName();
+
+		/**
+		 * The id of this mod, e.g. "fabric-example-mod"
+		 * @return null if the provided mod metadata does not include an id
+		 */
+		@Nullable
+		String getId();
+
+		/**
+		 * The path to the access widener of this mod.
+		 * @return null if the provided mod metadata does not include an access widener file
+		 */
+		@Nullable
+		String getAccessWidener();
+
+		/**
+		 * @return the list of injected interfaces. May be empty, but never null.
+		 */
+		List<InjectedInterface> getInjectedInterfaces();
+
+		@Nullable
+		String getProvidedJavadocPath();
+
+		record InjectedInterface(String modId, String className, String ifaceName) {
+		}
+	}
+}
diff --git a/src/main/java/net/fabricmc/loom/configuration/accesswidener/AccessWidenerFile.java b/src/main/java/net/fabricmc/loom/configuration/accesswidener/AccessWidenerFile.java
index 72c39b417441a0fbb590cb19c30c0911a2737333..054ff0d0d65348498e6db46d5a1652040c67d664 100644
--- a/src/main/java/net/fabricmc/loom/configuration/accesswidener/AccessWidenerFile.java
+++ b/src/main/java/net/fabricmc/loom/configuration/accesswidener/AccessWidenerFile.java
@@ -26,14 +26,14 @@ package net.fabricmc.loom.configuration.accesswidener;
 
 import java.io.IOException;
 import java.io.UncheckedIOException;
-import java.nio.charset.StandardCharsets;
 import java.nio.file.Path;
 import java.util.Arrays;
+import java.util.Map;
 import java.util.Objects;
 
-import com.google.gson.Gson;
-import com.google.gson.JsonObject;
-
+import net.fabricmc.loom.api.metadata.MetadataPriorities;
+import net.fabricmc.loom.configuration.ModMetadataHelper;
+import net.fabricmc.loom.util.ModUtils;
 import net.fabricmc.loom.util.ZipUtils;
 
 public record AccessWidenerFile(
@@ -44,34 +44,26 @@ public record AccessWidenerFile(
 	/**
 	 * Reads the access-widener contained in a mod jar, or returns null if there is none.
 	 */
-	public static AccessWidenerFile fromModJar(Path modJarPath) {
-		byte[] modJsonBytes;
-
-		try {
-			modJsonBytes = ZipUtils.unpackNullable(modJarPath, "fabric.mod.json");
-		} catch (IOException e) {
-			throw new UncheckedIOException("Failed to read access-widener file from: " + modJarPath.toAbsolutePath(), e);
-		}
+	public static AccessWidenerFile fromModJar(Map<String, ModMetadataHelper> helpers, MetadataPriorities priorities, Path modJarPath) {
+		ModMetadataHelper.Metadata metadata = ModUtils.readMetadataFromJar(helpers, priorities, modJarPath.toFile());
 
-		if (modJsonBytes == null) {
+		if (metadata == null) {
 			return null;
 		}
 
-		JsonObject jsonObject = new Gson().fromJson(new String(modJsonBytes, StandardCharsets.UTF_8), JsonObject.class);
+		String awPath = metadata.getAccessWidener();
+		String modId = metadata.getId();
 
-		if (!jsonObject.has("accessWidener")) {
+		if (awPath == null) {
 			return null;
 		}
 
-		String awPath = jsonObject.get("accessWidener").getAsString();
-		String modId = jsonObject.get("id").getAsString();
-
 		byte[] content;
 
 		try {
 			content = ZipUtils.unpack(modJarPath, awPath);
 		} catch (IOException e) {
-			throw new UncheckedIOException("Could not find access widener file (%s) defined in the fabric.mod.json file of %s".formatted(awPath, modJarPath.toAbsolutePath()), e);
+			throw new UncheckedIOException("Could not find access widener file (%s) defined in the mod metadata file of %s".formatted(awPath, modJarPath.toAbsolutePath()), e);
 		}
 
 		return new AccessWidenerFile(
diff --git a/src/main/java/net/fabricmc/loom/configuration/accesswidener/TransitiveAccessWidenerJarProcessor.java b/src/main/java/net/fabricmc/loom/configuration/accesswidener/TransitiveAccessWidenerJarProcessor.java
index 707158383f046e9bfa81b7b37affa5e9e09025ac..368142e7ca079028d835c13420a38f973ef56207 100644
--- a/src/main/java/net/fabricmc/loom/configuration/accesswidener/TransitiveAccessWidenerJarProcessor.java
+++ b/src/main/java/net/fabricmc/loom/configuration/accesswidener/TransitiveAccessWidenerJarProcessor.java
@@ -113,7 +113,7 @@ public class TransitiveAccessWidenerJarProcessor implements JarProcessor {
 				continue;
 			}
 
-			AccessWidenerFile accessWidener = AccessWidenerFile.fromModJar(path);
+			AccessWidenerFile accessWidener = AccessWidenerFile.fromModJar(extension.getModMetadataHelpers().get(), extension.getMetadataPriorities().get(), path);
 
 			if (accessWidener == null) {
 				continue;
diff --git a/src/main/java/net/fabricmc/loom/configuration/decompile/DecompileConfiguration.java b/src/main/java/net/fabricmc/loom/configuration/accesswidener/decompile/DecompileConfiguration.java
similarity index 97%
rename from src/main/java/net/fabricmc/loom/configuration/decompile/DecompileConfiguration.java
rename to src/main/java/net/fabricmc/loom/configuration/accesswidener/decompile/DecompileConfiguration.java
index 17718e8124db8e7ebb04b351b7d6498379856516..e77e060f644f09e7c72f5175137d688005cd77ee 100644
--- a/src/main/java/net/fabricmc/loom/configuration/decompile/DecompileConfiguration.java
+++ b/src/main/java/net/fabricmc/loom/configuration/accesswidener/decompile/DecompileConfiguration.java
@@ -22,7 +22,7 @@
  * SOFTWARE.
  */
 
-package net.fabricmc.loom.configuration.decompile;
+package net.fabricmc.loom.configuration.accesswidener.decompile;
 
 import java.io.File;
 
diff --git a/src/main/java/net/fabricmc/loom/configuration/decompile/SingleJarDecompileConfiguration.java b/src/main/java/net/fabricmc/loom/configuration/accesswidener/decompile/SingleJarDecompileConfiguration.java
similarity index 98%
rename from src/main/java/net/fabricmc/loom/configuration/decompile/SingleJarDecompileConfiguration.java
rename to src/main/java/net/fabricmc/loom/configuration/accesswidener/decompile/SingleJarDecompileConfiguration.java
index 782da7096a0eb1a9b604e77adf1a4fe1fb24a243..6e4bed4c3fcfa6fca81cd8541234d609e6c028d1 100644
--- a/src/main/java/net/fabricmc/loom/configuration/decompile/SingleJarDecompileConfiguration.java
+++ b/src/main/java/net/fabricmc/loom/configuration/accesswidener/decompile/SingleJarDecompileConfiguration.java
@@ -22,7 +22,7 @@
  * SOFTWARE.
  */
 
-package net.fabricmc.loom.configuration.decompile;
+package net.fabricmc.loom.configuration.accesswidener.decompile;
 
 import java.io.File;
 import java.nio.file.Path;
diff --git a/src/main/java/net/fabricmc/loom/configuration/decompile/SplitDecompileConfiguration.java b/src/main/java/net/fabricmc/loom/configuration/accesswidener/decompile/SplitDecompileConfiguration.java
similarity index 98%
rename from src/main/java/net/fabricmc/loom/configuration/decompile/SplitDecompileConfiguration.java
rename to src/main/java/net/fabricmc/loom/configuration/accesswidener/decompile/SplitDecompileConfiguration.java
index deb2982d3bdaafc1fc8a131873c76e3d68455c23..2edab5f6c70c64a3de51875e22410ee216bfbed2 100644
--- a/src/main/java/net/fabricmc/loom/configuration/decompile/SplitDecompileConfiguration.java
+++ b/src/main/java/net/fabricmc/loom/configuration/accesswidener/decompile/SplitDecompileConfiguration.java
@@ -22,7 +22,7 @@
  * SOFTWARE.
  */
 
-package net.fabricmc.loom.configuration.decompile;
+package net.fabricmc.loom.configuration.accesswidener.decompile;
 
 import java.io.File;
 
diff --git a/src/main/java/net/fabricmc/loom/configuration/ifaceinject/InterfaceInjectionProcessor.java b/src/main/java/net/fabricmc/loom/configuration/ifaceinject/InterfaceInjectionProcessor.java
index 033211390944bb090942ed7d8f167bacb244e158..600a85603d7302a7e1dff54efae10848c2a20880 100644
--- a/src/main/java/net/fabricmc/loom/configuration/ifaceinject/InterfaceInjectionProcessor.java
+++ b/src/main/java/net/fabricmc/loom/configuration/ifaceinject/InterfaceInjectionProcessor.java
@@ -24,11 +24,11 @@
 
 package net.fabricmc.loom.configuration.ifaceinject;
 
+import static net.fabricmc.loom.configuration.ModMetadataHelper.Metadata.InjectedInterface;
+
 import java.io.File;
 import java.io.IOException;
-import java.io.UncheckedIOException;
 import java.nio.charset.StandardCharsets;
-import java.nio.file.Files;
 import java.nio.file.Path;
 import java.util.ArrayList;
 import java.util.Collections;
@@ -44,9 +44,6 @@ import java.util.stream.Stream;
 import com.google.common.base.Preconditions;
 import com.google.common.hash.Hasher;
 import com.google.common.hash.Hashing;
-import com.google.gson.JsonArray;
-import com.google.gson.JsonElement;
-import com.google.gson.JsonObject;
 import org.gradle.api.Project;
 import org.gradle.api.tasks.SourceSet;
 import org.objectweb.asm.ClassReader;
@@ -55,15 +52,14 @@ import org.objectweb.asm.ClassWriter;
 import org.objectweb.asm.commons.Remapper;
 
 import net.fabricmc.loom.LoomGradleExtension;
-import net.fabricmc.loom.LoomGradlePlugin;
 import net.fabricmc.loom.api.InterfaceInjectionExtensionAPI;
 import net.fabricmc.loom.api.RemapConfigurationSettings;
+import net.fabricmc.loom.configuration.ModMetadataHelper;
 import net.fabricmc.loom.api.mappings.layered.MappingsNamespace;
 import net.fabricmc.loom.configuration.processors.JarProcessor;
 import net.fabricmc.loom.task.GenerateSourcesTask;
 import net.fabricmc.loom.util.Checksum;
 import net.fabricmc.loom.util.Constants;
-import net.fabricmc.loom.util.ModUtils;
 import net.fabricmc.loom.util.Pair;
 import net.fabricmc.loom.util.TinyRemapperHelper;
 import net.fabricmc.loom.util.ZipUtils;
@@ -193,33 +189,26 @@ public class InterfaceInjectionProcessor implements JarProcessor, GenerateSource
 		return extension.getCompileRemapConfigurations().stream()
 				.flatMap(resolve)
 				.filter(runtimeEntries::contains) // Use the intersection of the two configurations.
-				.flatMap(path -> InjectedInterface.fromModJar(path).stream())
+				.map(path -> extension.readMetadataFromJar(path.toFile()))
+				.filter(data -> data != null)
+				.flatMap(data -> data.getInjectedInterfaces().stream())
 				.toList();
 	}
 
 	private List<InjectedInterface> getSourceInjectedInterface(SourceSet sourceSet) {
-		final File fabricModJson;
+		final File metadataFile;
+		Map<String, ModMetadataHelper> helpers = extension.getModMetadataHelpers().get();
 
 		try {
-			fabricModJson = sourceSet.getResources()
-					.matching(patternFilterable -> patternFilterable.include("fabric.mod.json"))
+			metadataFile = sourceSet.getResources()
+					.matching(patternFilterable -> patternFilterable.include(helpers.keySet()))
 					.getSingleFile();
 		} catch (IllegalStateException e) {
 			// File not found
 			return Collections.emptyList();
 		}
 
-		final String jsonString;
-
-		try {
-			jsonString = Files.readString(fabricModJson.toPath(), StandardCharsets.UTF_8);
-		} catch (IOException e) {
-			throw new UncheckedIOException("Failed to read fabric.mod.json", e);
-		}
-
-		final JsonObject jsonObject = LoomGradlePlugin.GSON.fromJson(jsonString, JsonObject.class);
-
-		return InjectedInterface.fromJson(jsonObject);
+		return helpers.get(metadataFile.getName()).createMetadata(metadataFile).getInjectedInterfaces();
 	}
 
 	@Override
@@ -252,7 +239,7 @@ public class InterfaceInjectionProcessor implements JarProcessor, GenerateSource
 
 	private static String appendComment(String comment, List<InjectedInterface> injectedInterfaces) {
 		for (InjectedInterface injectedInterface : injectedInterfaces) {
-			String iiComment = "Interface {@link %s} injected by mod %s".formatted(injectedInterface.ifaceName.substring(injectedInterface.ifaceName.lastIndexOf("/") + 1), injectedInterface.modId);
+			String iiComment = "Interface {@link %s} injected by mod %s".formatted(injectedInterface.ifaceName().substring(injectedInterface.ifaceName().lastIndexOf("/") + 1), injectedInterface.modId());
 
 			if (comment == null || !comment.contains(iiComment)) {
 				if (comment == null) {
@@ -266,49 +253,6 @@ public class InterfaceInjectionProcessor implements JarProcessor, GenerateSource
 		return comment;
 	}
 
-	private record InjectedInterface(String modId, String className, String ifaceName) {
-		/**
-		 * Reads the injected interfaces contained in a mod jar, or returns empty if there is none.
-		 */
-		public static List<InjectedInterface> fromModJar(Path modJarPath) {
-			final JsonObject jsonObject = ModUtils.getFabricModJson(modJarPath);
-
-			if (jsonObject == null) {
-				return Collections.emptyList();
-			}
-
-			return fromJson(jsonObject);
-		}
-
-		public static List<InjectedInterface> fromJson(JsonObject jsonObject) {
-			final String modId = jsonObject.get("id").getAsString();
-
-			if (!jsonObject.has("custom")) {
-				return Collections.emptyList();
-			}
-
-			final JsonObject custom = jsonObject.getAsJsonObject("custom");
-
-			if (!custom.has(Constants.CustomModJsonKeys.INJECTED_INTERFACE)) {
-				return Collections.emptyList();
-			}
-
-			final JsonObject addedIfaces = custom.getAsJsonObject(Constants.CustomModJsonKeys.INJECTED_INTERFACE);
-
-			final List<InjectedInterface> result = new ArrayList<>();
-
-			for (String className : addedIfaces.keySet()) {
-				final JsonArray ifaceNames = addedIfaces.getAsJsonArray(className);
-
-				for (JsonElement ifaceName : ifaceNames) {
-					result.add(new InjectedInterface(modId, className, ifaceName.getAsString()));
-				}
-			}
-
-			return result;
-		}
-	}
-
 	private static class InjectingClassVisitor extends ClassVisitor {
 		private final List<InjectedInterface> injectedInterfaces;
 
diff --git a/src/main/java/net/fabricmc/loom/configuration/metadata/MetadataPrioritiesImpl.java b/src/main/java/net/fabricmc/loom/configuration/metadata/MetadataPrioritiesImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..83b15f333ae7a75658878fa9a91173a6b3dbc26b
--- /dev/null
+++ b/src/main/java/net/fabricmc/loom/configuration/metadata/MetadataPrioritiesImpl.java
@@ -0,0 +1,54 @@
+/*
+ * This file is part of fabric-loom, licensed under the MIT License (MIT).
+ *
+ * Copyright (c) 2022 FabricMC
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+package net.fabricmc.loom.configuration.metadata;
+
+import java.util.HashMap;
+
+import net.fabricmc.loom.api.metadata.MetadataPriorities;
+
+public class MetadataPrioritiesImpl implements MetadataPriorities {
+	private final HashMap<String, Integer> priorities = new HashMap<>();
+
+	public MetadataPrioritiesImpl() {
+		priorities.put("quilt.mod.json", 1);
+		priorities.put("fabric.mod.json", 0);
+	}
+
+	@Override
+	public void priority(String filename, int priority) {
+		priorities.put(filename, priority);
+	}
+
+	@Override
+	public int getPriority(String filename) {
+		Integer priority = priorities.get(filename);
+
+		if (priority == null) {
+			return -1;
+		}
+
+		return priority;
+	}
+}
diff --git a/src/main/java/net/fabricmc/loom/configuration/mods/AccessWidenerUtils.java b/src/main/java/net/fabricmc/loom/configuration/mods/AccessWidenerUtils.java
index 3f463919bddc185f2567ac00f5a3df888ed3f148..731977f8924cd23f592ea935578c04ced8db2a16 100644
--- a/src/main/java/net/fabricmc/loom/configuration/mods/AccessWidenerUtils.java
+++ b/src/main/java/net/fabricmc/loom/configuration/mods/AccessWidenerUtils.java
@@ -25,16 +25,21 @@
 package net.fabricmc.loom.configuration.mods;
 
 import java.io.IOException;
-import java.nio.charset.StandardCharsets;
 import java.nio.file.Path;
+import java.util.Map;
+
+import com.google.common.base.Preconditions;
+
+import net.fabricmc.loom.api.metadata.MetadataPriorities;
+import net.fabricmc.loom.configuration.ModMetadataHelper;
+
+import net.fabricmc.loom.util.ModUtils;
 
-import com.google.gson.JsonObject;
 import org.objectweb.asm.commons.Remapper;
 
 import net.fabricmc.accesswidener.AccessWidenerReader;
 import net.fabricmc.accesswidener.AccessWidenerRemapper;
 import net.fabricmc.accesswidener.AccessWidenerWriter;
-import net.fabricmc.loom.LoomGradlePlugin;
 import net.fabricmc.loom.api.mappings.layered.MappingsNamespace;
 import net.fabricmc.loom.util.ZipUtils;
 
@@ -57,15 +62,16 @@ public class AccessWidenerUtils {
 		return writer.write();
 	}
 
-	public static AccessWidenerData readAccessWidenerData(Path inputJar) throws IOException {
-		byte[] modJsonBytes = ZipUtils.unpack(inputJar, "fabric.mod.json");
-		JsonObject jsonObject = LoomGradlePlugin.GSON.fromJson(new String(modJsonBytes, StandardCharsets.UTF_8), JsonObject.class);
+	public static AccessWidenerData readAccessWidenerData(Map<String, ModMetadataHelper> helpers, MetadataPriorities priorities, Path inputJar) throws IOException {
+		Preconditions.checkArgument(ModUtils.isMod(helpers, inputJar), "Cannot nest jars into non-mod jar " + inputJar.toFile().getName());
+
+		ModMetadataHelper.Metadata metadata = ModUtils.readMetadataFromJar(helpers, priorities, inputJar.toFile());
+		String accessWidenerPath = metadata.getAccessWidener();
 
-		if (!jsonObject.has("accessWidener")) {
+		if (accessWidenerPath == null) {
 			return null;
 		}
 
-		String accessWidenerPath = jsonObject.get("accessWidener").getAsString();
 		byte[] accessWidener = ZipUtils.unpack(inputJar, accessWidenerPath);
 		AccessWidenerReader.Header header = AccessWidenerReader.readHeader(accessWidener);
 
diff --git a/src/main/java/net/fabricmc/loom/configuration/mods/ModConfigurationRemapper.java b/src/main/java/net/fabricmc/loom/configuration/mods/ModConfigurationRemapper.java
index 3f9f8bceb89b80709bd72eab4af0df5aa3a9bdb1..0b54c0de003db7da6fc76c6bc9c0cf2a20e580cb 100644
--- a/src/main/java/net/fabricmc/loom/configuration/mods/ModConfigurationRemapper.java
+++ b/src/main/java/net/fabricmc/loom/configuration/mods/ModConfigurationRemapper.java
@@ -88,7 +88,7 @@ public class ModConfigurationRemapper {
 				final List<ModDependency> modDependencies = new ArrayList<>();
 
 				for (ArtifactRef artifact : resolveArtifacts(project, sourceConfig)) {
-					if (!ModUtils.isMod(artifact.path())) {
+					if (!ModUtils.isMod(extension, artifact.path())) {
 						artifact.applyToConfiguration(project, targetConfig);
 						continue;
 					}
diff --git a/src/main/java/net/fabricmc/loom/configuration/mods/ModProcessor.java b/src/main/java/net/fabricmc/loom/configuration/mods/ModProcessor.java
index a5998ff8cb7c47ccfc2bd8b697771f85855896e7..e542fc576a660446f545992311a54aade1a92eae 100644
--- a/src/main/java/net/fabricmc/loom/configuration/mods/ModProcessor.java
+++ b/src/main/java/net/fabricmc/loom/configuration/mods/ModProcessor.java
@@ -43,6 +43,7 @@ import org.gradle.api.artifacts.Configuration;
 
 import net.fabricmc.loom.LoomGradleExtension;
 import net.fabricmc.loom.api.RemapConfigurationSettings;
+import net.fabricmc.loom.configuration.ModMetadataHelper;
 import net.fabricmc.loom.api.mappings.layered.MappingsNamespace;
 import net.fabricmc.loom.configuration.mods.dependency.ModDependency;
 import net.fabricmc.loom.configuration.providers.mappings.MappingsProviderImpl;
@@ -79,13 +80,17 @@ public class ModProcessor {
 		}
 	}
 
-	private void stripNestedJars(Path path) {
+	private void stripNestedJars(LoomGradleExtension ext, Path path) {
 		// Strip out all contained jar info as we dont want loader to try and load the jars contained in dev.
 		try {
-			ZipUtils.transformJson(JsonObject.class, path, Map.of("fabric.mod.json", json -> {
-				json.remove("jars");
-				return json;
-			}));
+			// TODO: cache?
+			Map<String, ZipUtils.UnsafeUnaryOperator<JsonObject>> map = new HashMap<>();
+
+			for (ModMetadataHelper value : ext.getModMetadataHelpers().get().values()) {
+				map.put(value.getFileName(), value.stripNestedJarsFunction());
+			}
+
+			ZipUtils.transformJson(JsonObject.class, path, map);
 		} catch (IOException e) {
 			throw new UncheckedIOException("Failed to strip nested jars from %s".formatted(path), e);
 		}
@@ -151,7 +156,7 @@ public class ModProcessor {
 					outputConsumer.addNonClassFiles(dependency.getInputFile(), NonClassCopyMode.FIX_META_INF, remapper);
 					outputConsumerMap.put(dependency, outputConsumer);
 
-					final AccessWidenerUtils.AccessWidenerData accessWidenerData = AccessWidenerUtils.readAccessWidenerData(dependency.getInputFile());
+					final AccessWidenerUtils.AccessWidenerData accessWidenerData = AccessWidenerUtils.readAccessWidenerData(extension.getModMetadataHelpers().get(), extension.getMetadataPriorities().get(), dependency.getInputFile());
 
 					if (accessWidenerData != null) {
 						project.getLogger().debug("Remapping access widener in {}", dependency.getInputFile());
@@ -182,7 +187,7 @@ public class ModProcessor {
 				ZipUtils.replace(output, accessWidener.right(), accessWidener.left());
 			}
 
-			stripNestedJars(output);
+			stripNestedJars(extension, output);
 			remapJarManifestEntries(output);
 			dependency.copyToCache(project, output, null);
 		}
diff --git a/src/main/java/net/fabricmc/loom/configuration/processors/ModJavadocProcessor.java b/src/main/java/net/fabricmc/loom/configuration/processors/ModJavadocProcessor.java
index b06447fe6660f3664a2febcdde0897840e15df33..f17a6c683593fa79a3c72bd45b3dda962faa4fd3 100644
--- a/src/main/java/net/fabricmc/loom/configuration/processors/ModJavadocProcessor.java
+++ b/src/main/java/net/fabricmc/loom/configuration/processors/ModJavadocProcessor.java
@@ -35,7 +35,6 @@ import java.util.ArrayList;
 import java.util.List;
 import java.util.Set;
 
-import com.google.gson.JsonObject;
 import org.gradle.api.Project;
 import org.jetbrains.annotations.Nullable;
 import org.slf4j.Logger;
@@ -44,6 +43,7 @@ import org.slf4j.LoggerFactory;
 import net.fabricmc.loom.LoomGradleExtension;
 import net.fabricmc.loom.api.RemapConfigurationSettings;
 import net.fabricmc.loom.api.mappings.layered.MappingsNamespace;
+import net.fabricmc.loom.configuration.ModMetadataHelper;
 import net.fabricmc.loom.task.GenerateSourcesTask;
 import net.fabricmc.loom.util.Constants;
 import net.fabricmc.loom.util.ModUtils;
@@ -70,14 +70,14 @@ public final class ModJavadocProcessor implements JarProcessor, GenerateSourcesT
 			final Set<File> artifacts = entry.getSourceConfiguration().get().resolve();
 
 			for (File artifact : artifacts) {
-				if (!ModUtils.isMod(artifact.toPath())) {
+				if (!ModUtils.isMod(extension, artifact.toPath())) {
 					continue;
 				}
 
 				final ModJavadoc modJavadoc;
 
 				try {
-					modJavadoc = ModJavadoc.fromModJar(artifact.toPath());
+					modJavadoc = ModJavadoc.fromModJar(extension, artifact.toPath());
 				} catch (IOException e) {
 					throw new UncheckedIOException("Failed to read mod jar (%s)".formatted(artifact), e);
 				}
@@ -120,21 +120,15 @@ public final class ModJavadocProcessor implements JarProcessor, GenerateSourcesT
 
 	public record ModJavadoc(String modId, MemoryMappingTree mappingTree) {
 		@Nullable
-		public static ModJavadoc fromModJar(Path path) throws IOException {
-			JsonObject jsonObject = ModUtils.getFabricModJson(path);
+		public static ModJavadoc fromModJar(LoomGradleExtension ext, Path path) throws IOException {
+			ModMetadataHelper.Metadata metadata = ModUtils.readMetadataFromJar(ext, path);
+			final String modId = metadata.getId();
+			final String javaDocPath = metadata.getProvidedJavadocPath();
 
-			if (jsonObject == null || !jsonObject.has("custom")) {
+			if (javaDocPath == null) {
 				return null;
 			}
 
-			final String modId = jsonObject.get("id").getAsString();
-			final JsonObject custom = jsonObject.getAsJsonObject("custom");
-
-			if (!custom.has(Constants.CustomModJsonKeys.PROVIDED_JAVADOC)) {
-				return null;
-			}
-
-			final String javaDocPath = custom.getAsJsonPrimitive(Constants.CustomModJsonKeys.PROVIDED_JAVADOC).getAsString();
 			final byte[] data = ZipUtils.unpack(path, javaDocPath);
 			final MemoryMappingTree mappings = new MemoryMappingTree();
 
diff --git a/src/main/java/net/fabricmc/loom/configuration/providers/minecraft/MinecraftJarConfiguration.java b/src/main/java/net/fabricmc/loom/configuration/providers/minecraft/MinecraftJarConfiguration.java
index 48a4ca9cf0be251c00f3328b615303ff6dfe44cc..9d6901af75e8e6e057735b2d5317c63d87aad664 100644
--- a/src/main/java/net/fabricmc/loom/configuration/providers/minecraft/MinecraftJarConfiguration.java
+++ b/src/main/java/net/fabricmc/loom/configuration/providers/minecraft/MinecraftJarConfiguration.java
@@ -30,9 +30,9 @@ import java.util.function.Function;
 
 import org.gradle.api.Project;
 
-import net.fabricmc.loom.configuration.decompile.DecompileConfiguration;
-import net.fabricmc.loom.configuration.decompile.SingleJarDecompileConfiguration;
-import net.fabricmc.loom.configuration.decompile.SplitDecompileConfiguration;
+import net.fabricmc.loom.configuration.accesswidener.decompile.DecompileConfiguration;
+import net.fabricmc.loom.configuration.accesswidener.decompile.SingleJarDecompileConfiguration;
+import net.fabricmc.loom.configuration.accesswidener.decompile.SplitDecompileConfiguration;
 import net.fabricmc.loom.configuration.processors.JarProcessorManager;
 import net.fabricmc.loom.configuration.providers.minecraft.mapped.IntermediaryMinecraftProvider;
 import net.fabricmc.loom.configuration.providers.minecraft.mapped.MappedMinecraftProvider;
diff --git a/src/main/java/net/fabricmc/loom/extension/LoomGradleExtensionApiImpl.java b/src/main/java/net/fabricmc/loom/extension/LoomGradleExtensionApiImpl.java
index abfc70bdc6b7ab6e99a4bb4b2b5df173f660b2d2..8a3ec738fe0ffcca17dfd8734cf2e67dabf498fd 100644
--- a/src/main/java/net/fabricmc/loom/extension/LoomGradleExtensionApiImpl.java
+++ b/src/main/java/net/fabricmc/loom/extension/LoomGradleExtensionApiImpl.java
@@ -34,6 +34,7 @@ import org.gradle.api.artifacts.Dependency;
 import org.gradle.api.file.ConfigurableFileCollection;
 import org.gradle.api.file.RegularFileProperty;
 import org.gradle.api.provider.ListProperty;
+import org.gradle.api.provider.MapProperty;
 import org.gradle.api.provider.Property;
 import org.gradle.api.publish.maven.MavenPublication;
 import org.gradle.api.tasks.SourceSet;
@@ -49,6 +50,11 @@ import net.fabricmc.loom.api.mappings.intermediate.IntermediateMappingsProvider;
 import net.fabricmc.loom.api.mappings.layered.spec.LayeredMappingSpecBuilder;
 import net.fabricmc.loom.configuration.RemapConfigurations;
 import net.fabricmc.loom.configuration.ide.RunConfigSettings;
+import net.fabricmc.loom.api.metadata.MetadataPriorities;
+import net.fabricmc.loom.build.FabricModMetadataHelper;
+import net.fabricmc.loom.build.QuiltModMetadataHelper;
+import net.fabricmc.loom.configuration.ModMetadataHelper;
+import net.fabricmc.loom.configuration.metadata.MetadataPrioritiesImpl;
 import net.fabricmc.loom.configuration.processors.JarProcessor;
 import net.fabricmc.loom.configuration.providers.mappings.GradleMappingContext;
 import net.fabricmc.loom.configuration.providers.mappings.LayeredMappingSpec;
@@ -78,7 +84,8 @@ public abstract class LoomGradleExtensionApiImpl implements LoomGradleExtensionA
 	private final Property<MinecraftJarConfiguration> minecraftJarConfiguration;
 	private final Property<Boolean> splitEnvironmentalSourceSet;
 	private final InterfaceInjectionExtensionAPI interfaceInjectionExtension;
-
+	private final MapProperty<String, ModMetadataHelper> modMetadataHelpers;
+	private final Property<MetadataPriorities> metadataPriorities;
 	private final ModVersionParser versionParser;
 
 	private final NamedDomainObjectContainer<RunConfigSettings> runConfigs;
@@ -134,6 +141,14 @@ public abstract class LoomGradleExtensionApiImpl implements LoomGradleExtensionA
 		this.splitEnvironmentalSourceSet = project.getObjects().property(Boolean.class).convention(false);
 		this.splitEnvironmentalSourceSet.finalizeValueOnRead();
 
+		this.modMetadataHelpers = project.getObjects().mapProperty(String.class, ModMetadataHelper.class);
+		this.addModMetadataHelper(new FabricModMetadataHelper());
+		this.addModMetadataHelper(new QuiltModMetadataHelper());
+		this.modMetadataHelpers.finalizeValueOnRead();
+
+		this.metadataPriorities = project.getObjects().property(MetadataPriorities.class).convention(new MetadataPrioritiesImpl());
+		this.metadataPriorities.finalizeValueOnRead();
+
 		// Add main source set by default
 		interfaceInjection(interfaceInjection -> {
 			final SourceSet main = SourceSetHelper.getMainSourceSet(project);
@@ -178,6 +193,20 @@ public abstract class LoomGradleExtensionApiImpl implements LoomGradleExtensionA
 		return layered(LayeredMappingSpecBuilder::officialMojangMappings);
 	}
 
+	public MapProperty<String, ModMetadataHelper> getModMetadataHelpers() {
+		return modMetadataHelpers;
+	}
+
+	@Override
+	public void metadataPriorities(Action<MetadataPriorities> action) {
+		action.execute(metadataPriorities.get());
+	}
+
+	@Override
+	public Property<MetadataPriorities> getMetadataPriorities() {
+		return metadataPriorities;
+	}
+
 	@Override
 	public Dependency layered(Action<LayeredMappingSpecBuilder> action) {
 		LayeredMappingSpecBuilderImpl builder = new LayeredMappingSpecBuilderImpl();
diff --git a/src/main/java/net/fabricmc/loom/extension/ModVersionParser.java b/src/main/java/net/fabricmc/loom/extension/ModVersionParser.java
index 0ded46291e053224f91e053ecd5a70c25e2720a2..c56f83fcd0f59dcd38a8ca048bb35823c5a18ad2 100644
--- a/src/main/java/net/fabricmc/loom/extension/ModVersionParser.java
+++ b/src/main/java/net/fabricmc/loom/extension/ModVersionParser.java
@@ -25,14 +25,13 @@
 package net.fabricmc.loom.extension;
 
 import java.io.File;
-import java.io.FileReader;
-import java.io.IOException;
 
-import com.google.gson.JsonObject;
 import org.gradle.api.Project;
 import org.gradle.api.plugins.JavaPluginExtension;
+import org.jetbrains.annotations.Nullable;
 
-import net.fabricmc.loom.LoomGradlePlugin;
+import net.fabricmc.loom.api.LoomGradleExtensionAPI;
+import net.fabricmc.loom.configuration.ModMetadataHelper;
 
 public class ModVersionParser {
 	private final Project project;
@@ -48,29 +47,41 @@ public class ModVersionParser {
 			return version;
 		}
 
-		File json = locateModJsonFile();
-		JsonObject jsonObject;
+		for (ModMetadataHelper helperFactory : project.getExtensions().getByType(LoomGradleExtensionAPI.class).getModMetadataHelpers().get().values()) {
+			File metadata = locateModMetadata(helperFactory.getFileName());
 
-		try (var reader = new FileReader(json)) {
-			jsonObject = LoomGradlePlugin.GSON.fromJson(reader, JsonObject.class);
-		} catch (IOException e) {
-			throw new RuntimeException("Failed to read fabric.mod.json file");
-		}
+			if (metadata == null) {
+				continue;
+			}
+
+			ModMetadataHelper.Metadata helper;
+
+			try {
+				helper = helperFactory.createMetadata(metadata);
+			} catch (UnsupportedOperationException ignored) {
+				continue;
+			}
 
-		if (!jsonObject.has("version") || !jsonObject.get("version").isJsonPrimitive()) {
-			throw new UnsupportedOperationException("Could not find valid version in the fabric.mod.json file");
+			version = helper.getVersion();
+			break;
 		}
 
-		version = jsonObject.get("version").getAsString();
+		if (version == null) {
+			throw new UnsupportedOperationException("Unable to find the version in the mod metadata!");
+		}
 
 		return version;
 	}
 
-	private File locateModJsonFile() {
-		return project.getExtensions().getByType(JavaPluginExtension.class).getSourceSets()
-				.getByName("main")
-				.getResources()
-				.matching(patternFilterable -> patternFilterable.include("fabric.mod.json"))
-				.getSingleFile();
+	private @Nullable File locateModMetadata(String fileName) {
+		try {
+			return project.getExtensions().getByType(JavaPluginExtension.class).getSourceSets()
+					.getByName("main")
+					.getResources()
+					.matching(patternFilterable -> patternFilterable.include(fileName))
+					.getSingleFile();
+		} catch (IllegalStateException e) {
+			return null;
+		}
 	}
 }
diff --git a/src/main/java/net/fabricmc/loom/task/RemapJarTask.java b/src/main/java/net/fabricmc/loom/task/RemapJarTask.java
index 5fc7a01f24dcd788c7feac507c3b3f5f984c8a26..1139bfb0b86f07de97e1071c072cad9d5aa87fcc 100644
--- a/src/main/java/net/fabricmc/loom/task/RemapJarTask.java
+++ b/src/main/java/net/fabricmc/loom/task/RemapJarTask.java
@@ -45,6 +45,7 @@ import org.gradle.api.file.ConfigurableFileCollection;
 import org.gradle.api.file.FileCollection;
 import org.gradle.api.plugins.JavaPlugin;
 import org.gradle.api.provider.ListProperty;
+import org.gradle.api.provider.MapProperty;
 import org.gradle.api.provider.Property;
 import org.gradle.api.tasks.Input;
 import org.gradle.api.tasks.InputFiles;
@@ -58,9 +59,10 @@ import net.fabricmc.accesswidener.AccessWidenerReader;
 import net.fabricmc.accesswidener.AccessWidenerRemapper;
 import net.fabricmc.accesswidener.AccessWidenerWriter;
 import net.fabricmc.loom.LoomGradleExtension;
-import net.fabricmc.loom.build.MixinRefmapHelper;
+import net.fabricmc.loom.api.metadata.MetadataPriorities;
 import net.fabricmc.loom.build.nesting.IncludedJarFactory;
 import net.fabricmc.loom.build.nesting.JarNester;
+import net.fabricmc.loom.configuration.ModMetadataHelper;
 import net.fabricmc.loom.configuration.accesswidener.AccessWidenerFile;
 import net.fabricmc.loom.configuration.providers.minecraft.MinecraftSourceSets;
 import net.fabricmc.loom.extension.MixinExtension;
@@ -127,6 +129,8 @@ public abstract class RemapJarTask extends AbstractRemapJarTask {
 
 			final boolean legacyMixin = extension.getMixin().getUseLegacyMixinAp().get();
 			params.getUseMixinExtension().set(!legacyMixin);
+			params.getMetadataHelpers().set(extension.getModMetadataHelpers());
+			params.getMetadataPriorities().set(extension.getMetadataPriorities());
 
 			if (legacyMixin) {
 				setupLegacyMixinRefmapRemapping(params);
@@ -138,14 +142,14 @@ public abstract class RemapJarTask extends AbstractRemapJarTask {
 		final LoomGradleExtension extension = LoomGradleExtension.get(getProject());
 		final MixinExtension mixinExtension = extension.getMixin();
 
-		final JsonObject fabricModJson = ModUtils.getFabricModJson(getInputFile().getAsFile().get().toPath());
+		ModMetadataHelper.Metadata helper = extension.readMetadataFromJar(getInputFile().getAsFile().get());
 
-		if (fabricModJson == null) {
-			getProject().getLogger().warn("Could not find fabric.mod.json file in: " + getInputFile().getAsFile().get().getName());
+		if (helper == null) {
+			getProject().getLogger().warn("Could not find a metadata file in: " + getInputFile().getAsFile().get().getName());
 			return;
 		}
 
-		final Collection<String> allMixinConfigs = MixinRefmapHelper.getMixinConfigurationFiles(fabricModJson);
+		final Collection<String> allMixinConfigs = helper.getMixinConfigurationFiles();
 
 		for (SourceSet sourceSet : mixinExtension.getMixinSourceSets()) {
 			MixinExtension.MixinInformationContainer container = Objects.requireNonNull(
@@ -177,6 +181,10 @@ public abstract class RemapJarTask extends AbstractRemapJarTask {
 		ListProperty<RefmapData> getMixinData();
 
 		Property<String> getTinyRemapperBuildServiceUuid();
+		MapProperty<String, String> getManifestAttributes();
+		ListProperty<String> getClientOnlyClasses();
+		MapProperty<String, ModMetadataHelper> getMetadataHelpers();
+		Property<MetadataPriorities> getMetadataPriorities();
 	}
 
 	public abstract static class RemapAction extends AbstractRemapAction<RemapParams> {
@@ -237,7 +245,7 @@ public abstract class RemapJarTask extends AbstractRemapJarTask {
 		}
 
 		private void remapAccessWidener() throws IOException {
-			final AccessWidenerFile accessWidenerFile = AccessWidenerFile.fromModJar(inputFile);
+			final AccessWidenerFile accessWidenerFile = AccessWidenerFile.fromModJar(getParameters().getMetadataHelpers().get(), getParameters().getMetadataPriorities().get(), inputFile);
 
 			if (accessWidenerFile == null) {
 				return;
@@ -273,7 +281,7 @@ public abstract class RemapJarTask extends AbstractRemapJarTask {
 				return;
 			}
 
-			JarNester.nestJars(nestedJars.getFiles(), outputFile.toFile(), LOGGER);
+			JarNester.nestJars(this.getParameters().getMetadataHelpers().get(), this.getParameters().getMetadataPriorities().get(), nestedJars.getFiles(), outputFile.toFile(), LOGGER);
 		}
 
 		private void addRefmaps() throws IOException {
diff --git a/src/main/java/net/fabricmc/loom/util/ModUtils.java b/src/main/java/net/fabricmc/loom/util/ModUtils.java
index 31298d953d72849b38f9a41b3f5bbbb565a81397..ebf1c62baaad01ac996c78c1b32776530777b3b1 100644
--- a/src/main/java/net/fabricmc/loom/util/ModUtils.java
+++ b/src/main/java/net/fabricmc/loom/util/ModUtils.java
@@ -1,7 +1,7 @@
 /*
  * This file is part of fabric-loom, licensed under the MIT License (MIT).
  *
- * Copyright (c) 2016-2022 FabricMC
+ * Copyright (c) 2016-2021 FabricMC
  *
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -26,30 +26,84 @@ package net.fabricmc.loom.util;
 
 import java.io.File;
 import java.io.IOException;
-import java.io.UncheckedIOException;
+import java.io.InputStreamReader;
 import java.nio.file.Path;
+import java.util.List;
+import java.util.Map;
+import java.util.zip.ZipFile;
 
-import com.google.gson.JsonObject;
-import org.jetbrains.annotations.Nullable;
+import net.fabricmc.loom.LoomGradleExtension;
+import net.fabricmc.loom.api.LoomGradleExtensionAPI;
+import net.fabricmc.loom.api.metadata.MetadataPriorities;
+import net.fabricmc.loom.configuration.ModMetadataHelper;
 
 public final class ModUtils {
 	private ModUtils() {
 	}
 
-	public static boolean isMod(File file) {
-		return isMod(file.toPath());
+	// Also accept Path for isMod
+	public static boolean isMod(LoomGradleExtensionAPI ext, Path input) {
+		return ZipUtils.containsAny(input, ext.getModMetadataHelpers().get().keySet());
 	}
 
-	public static boolean isMod(Path input) {
-		return ZipUtils.contains(input, "fabric.mod.json");
+	public static boolean isMod(Map<String, ModMetadataHelper> helpers, Path input) {
+		return ZipUtils.containsAny(input, helpers.keySet());
 	}
 
-	@Nullable
-	public static JsonObject getFabricModJson(Path path) {
-		try {
-			return ZipUtils.unpackGsonNullable(path, "fabric.mod.json", JsonObject.class);
+	public static boolean isMod(LoomGradleExtensionAPI ext, File input) {
+		return isMod(ext, input.toPath());
+	}
+
+	public static boolean isMod(Map<String, ModMetadataHelper> helpers, File input) {
+		return isMod(helpers, input.toPath());
+	}
+
+	/**
+	 * @throws UnsupportedOperationException if the metadata that is found cannot be read.
+	 */
+	public static ModMetadataHelper.Metadata readMetadataFromJar(LoomGradleExtensionAPI ext, File jar) {
+		return ModUtils.readMetadataFromJar(ext.getModMetadataHelpers().get(), ext.getMetadataPriorities().get(), jar);
+	}
+
+	public static ModMetadataHelper.Metadata readMetadataFromJar(LoomGradleExtension ext, Path jar) {
+		return readMetadataFromJar(ext.getModMetadataHelpers().get(), ext.getMetadataPriorities().get(), jar.toFile());
+	}
+
+	/**
+	 * @throws UnsupportedOperationException if the metadata that is found cannot be read.
+	 */
+	public static ModMetadataHelper.Metadata readMetadataFromJar(Map<String, ModMetadataHelper> helpers, MetadataPriorities priorities, File jar) {
+		try (var zip = new ZipFile(jar)) {
+			List<String> entries = helpers.keySet()
+					.stream()
+					.filter(name -> zip.getEntry(name) != null)
+					.toList();
+
+			if (entries.isEmpty()) {
+				return null;
+			}
+
+			// Picks the metadata with the highest priority.
+			String fileName = entries.get(0);
+
+			if (entries.size() > 1) {
+				int curPriority = priorities.getPriority(fileName);
+
+				for (String entry : entries) {
+					int newPriority = priorities.getPriority(entry);
+
+					if (newPriority > curPriority) {
+						curPriority = newPriority;
+						fileName = entry;
+					}
+				}
+			}
+
+			try (InputStreamReader reader = new InputStreamReader(zip.getInputStream(zip.getEntry(fileName)))) {
+				return helpers.get(fileName).createMetadata(reader);
+			}
 		} catch (IOException e) {
-			throw new UncheckedIOException("Failed to extract fabric.mod.json from " + path, e);
+			throw new UnsupportedOperationException("Cannot read metadata in the jar.", e);
 		}
 	}
 }
diff --git a/src/main/java/net/fabricmc/loom/util/ZipUtils.java b/src/main/java/net/fabricmc/loom/util/ZipUtils.java
index f6214aed8a99b99af52dcca76d78a36c2cf29213..8bfbc8c69cdcbf60b3f73dada8e12b033dfb198a 100644
--- a/src/main/java/net/fabricmc/loom/util/ZipUtils.java
+++ b/src/main/java/net/fabricmc/loom/util/ZipUtils.java
@@ -77,6 +77,22 @@ public class ZipUtils {
 		}
 	}
 
+	public static boolean containsAny(Path zip, Collection<String> paths) {
+		try (FileSystemUtil.Delegate fs = FileSystemUtil.getJarFileSystem(zip, false)) {
+			for (String path : paths) {
+				Path fsPath = fs.get().getPath(path);
+
+				if (Files.exists(fsPath)) {
+					return true;
+				}
+			}
+
+			return false;
+		} catch (IOException e) {
+			throw new UncheckedIOException("Failed to check file from zip", e);
+		}
+	}
+
 	public static void unpackAll(Path zip, Path output) throws IOException {
 		try (FileSystemUtil.Delegate fs = FileSystemUtil.getJarFileSystem(zip, false);
 				Stream<Path> walk = Files.walk(fs.get().getPath("/"))) {
diff --git a/src/test/groovy/net/fabricmc/loom/test/util/GradleProjectTestTrait.groovy b/src/test/groovy/net/fabricmc/loom/test/util/GradleProjectTestTrait.groovy
index 521b24bc4f670718d738f6f2df5e1bbae499e385..d2684c0fa8023bdff7ce8fe85e4a11594ce62eeb 100644
--- a/src/test/groovy/net/fabricmc/loom/test/util/GradleProjectTestTrait.groovy
+++ b/src/test/groovy/net/fabricmc/loom/test/util/GradleProjectTestTrait.groovy
@@ -243,7 +243,7 @@ trait GradleProjectTestTrait {
         }
 
         File getGeneratedSources(String mappings) {
-            return new File(getGradleHomeDir(), "caches/fabric-loom/${mappings}/minecraft-merged-named-sources.jar")
+            return new File(getGradleHomeDir(), "caches/quilt-loom/${mappings}/minecraft-merged-named-sources.jar")
         }
 
         File getGeneratedLocalSources(String mappings) {
